# Step2: 視点の分離

## 🎯 学習目標

**このステップを通じて、あなたはこう説明できるようになります：**

> 「**ホスト視点**と**コンテナ視点**は異なり、どの視点で見ているかを意識することが重要です」

**所要時間: 約30分**

---

## 📋 今回のテーマ：「どこから見ているか」を意識する

### 🏢 「視点」の語源とアナロジー

**Viewpoint（視点）** = **見る場所・立場**

建物と部屋の関係で考えてみましょう：

```
建物の世界                        コンテナの世界
┌─────────────────────────────────────────────────────────────────────────────┐
│ 🏢 建物（ホスト）                    💻 ホスト                                  │
│                                                                             │
│ • 外から建物を見る視点              • 外からコンテナを見る視点                　　  │
│ • 窓が開いていれば中が見える         • ポートが公開されていれば中にアクセス可能       　│
│ • 窓が閉まっていれば中は見えない   　 • ポートが非公開なら中にアクセス不可     　　　　　│
│                                                                             │
│ 🚪 部屋（コンテナ）                  🐳 コンテナ                            　   │
│                                                                             │
│ • 部屋の中から見る視点              • コンテナの中から見る視点               　　   │
│ • 部屋同士は廊下で繋がっている      　• コンテナ同士はネットワークで繋がっている        │
│ • 外の世界は窓を通してしか見えない　　 • 外の世界はポート公開を通してしか見えない        │
└─────────────────────────────────────────────────────────────────────────────┘

例：オフィスビルの会議室              例：Webサーバーのコンテナ
   営業部の部屋                       データベースのコンテナ
```

**重要な気づき：**
- **部屋の中では電気がついていても、窓が閉まっていれば外からは見えない**
- **コンテナの中でアプリが動いていても、ポートが公開されていなければ外からアクセスできない**

### 🔍 中心となる問い

> **同じアプリケーションなのに、なぜ「見る場所」によって見え方が違うのか？**

### 💡 実務での価値

- **デバッグ時の視点切り替え**（問題はどこから見た時に起きるか）
- **セキュリティ設計**（どの視点からアクセス可能にするか）
- **ネットワーク設計**（内部通信 vs 外部公開の使い分け）

---

## 🤔 なぜこの学習が重要なのか

### 実務でよくある混乱

**場面1: 「コンテナ内では動いているのに...」**
```
「docker exec で入ってcurlすると応答があるのに、
 ホストからcurlすると繋がりません」
「コンテナは正常に動作しているはずなのに...」
```

**場面2: 「ローカルでは動くのに本番で...」**
```
「開発環境では問題ないのに、本番環境でAPIが呼べません」
「設定は同じはずなのに、なぜ？」
```

**場面3: 「セキュリティ監査での指摘」**
```
「このAPIサーバー、外部公開する必要ありますか？」
「内部からのアクセスだけで十分では？」
```

### 多くのエンジニアが混同すること

❌ **「動いている = アクセスできる」**
- アプリケーションが動作していても、視点によってアクセス可否が変わる

❌ **「同じ設定なら同じ結果」**
- 見る場所（視点）が違えば、同じ設定でも結果が異なる

❌ **「エラーが出たら設定が間違っている」**
- 設定は正しくても、視点の違いでエラーになることがある

✅ **正しい理解**
- **ホスト視点**：外部からコンテナを見る（ポート公開が必要）
- **コンテナ視点**：コンテナ内部から見る（直接アクセス可能）
- **ネットワーク視点**：同一ネットワーク内から見る（サービス名でアクセス）

---

## 🏗️ 今回の構成を理解する

### 現在の状態：ホスト視点でAPIアクセス不可
```
ホスト視点（外から建物を見る）
┌─────────────────────────────────────────────────────────────┐
│                      🏢 ホスト                            　　│
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐      │
│  │  Frontend   │    │   Backend   │    │  Database   │      │
│  │   :3000     │    │    :8000    │    │    :5432    │      │
│  │      ✅     │    │      ❌      │  　│      ❌  　　│      │
│  │   窓が開く   │    │   窓が閉じる  │    │   窓が閉じる　│      │
│  └─────────────┘    └─────────────┘    └─────────────┘      │
└─────────────────────────────────────────────────────────────┘
        ↑                     ↑                ↑
   ✅ 見える               ❌ 見えない        ❌ 見えない
   (ポート公開あり)        (ポート公開なし)   (ポート公開なし)
```

### コンテナ視点（部屋の中から見る）
```
コンテナ視点（同じネットワーク内）
┌─────────────────────────────────────────────────────────────┐
│                    app-network                              │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐     │
│  │  Frontend   │───▶│   Backend   │───▶│  Database   │     │
│  │   :3000     │    │    :8000    │    │    :5432    │     │
│  │      ✅      │    │      ✅      │    │      ✅      │     │
│  │   部屋で稼働 │    │   部屋で稼働 │    │   部屋で稼働 │     │
│  └─────────────┘    └─────────────┘    └─────────────┘     │
└─────────────────────────────────────────────────────────────┘
        ↑                     ↑                ↑
   ✅ 通信可能             ✅ 通信可能        ✅ 通信可能
   (ネットワーク内)        (ネットワーク内)   (ネットワーク内)
```

**重要な気づき：**
> **同じアプリケーションでも、どの視点から見るかで「見え方」が全く違う**

---

## 🚀 実習手順

> **目的**: 視点の違いによる見え方の差を体験し、「どこから見ているか」を意識できるようになる

### 1. 環境の掃除（このプロジェクトのリソースのみ削除、他の環境には影響なし）
```bash
docker compose down -v --remove-orphans
```

### 2. 現在の状態を確認（問題のある状態）
```bash
# コンテナを起動
docker compose up -d

# 起動状況の確認
docker compose ps
```

**💡 注意**: 初回起動時やDockerfileが更新された場合は、以下でイメージをリビルドしてください：
```bash
docker compose build
docker compose up -d
```

**期待する結果:**
```
NAME                     COMMAND                  PORTS
infra-handson-backend    "docker-entrypoint.s…"  8000/tcp
infra-handson-database   "docker-entrypoint.s…"  5432/tcp
infra-handson-frontend   "docker-entrypoint.s…"  0.0.0.0:3000->3000/tcp
```

**注目ポイント:**
- Frontend: `0.0.0.0:3000->3000/tcp` （ホスト視点でアクセス可能）
- Backend: `8000/tcp` （ホスト視点でアクセス不可）
- Database: `5432/tcp` （ホスト視点でアクセス不可）

### 3. ホスト視点での確認

#### 3-1. フロントエンド確認（成功するはず）
```bash
# ブラウザでアクセス
open http://localhost:3000
```

**期待する結果:**
- ✅ タスク管理画面が表示される
- ❌ ただし、APIエラーが表示される（バックエンドにアクセスできないため）

#### 3-2. バックエンドAPI確認（失敗するはず）
```bash
curl http://localhost:8000/health
```

**期待する結果:**
```
curl: (7) Failed to connect to localhost port 8000: Connection refused
```

### 4. コンテナ視点での確認

#### 4-1. フロントエンドコンテナ内からバックエンドにアクセス
```bash
# フロントエンドコンテナに入る
docker compose exec frontend sh

# コンテナ内からバックエンドにアクセス（成功するはず）
curl http://backend:8000/health

# コンテナから出る
exit
```

**期待する結果:**
```json
{"status":"OK","message":"Task API is running"}
```

#### 4-2. バックエンドコンテナ内から自分自身にアクセス
```bash
# バックエンドコンテナに入る
docker compose exec backend sh

# コンテナ内から自分自身にアクセス（成功するはず）
curl http://localhost:8000/health

# コンテナから出る
exit
```

**期待する結果:**
```json
{"status":"OK","message":"Task API is running"}
```

### 5. 視点の違いを理解する

**🤔 考えてみましょう:**
1. なぜホスト視点ではバックエンドにアクセスできないのか？
2. なぜコンテナ視点では同じバックエンドにアクセスできるのか？
3. フロントエンドはなぜホスト視点でもアクセスできるのか？

<details>
<summary>ヒントを見る</summary>

建物のアナロジーで考えてください：
- **窓が開いている部屋**：外からも中からも見える
- **窓が閉まっている部屋**：外からは見えないが、中では活動している
- **廊下**：部屋同士は廊下（ネットワーク）で繋がっている

</details>

### 6. 問題を修正する

#### 6-1. docker-compose.ymlを確認
```bash
cat docker-compose.yml
```

バックエンドの設定を見てください：
```yaml
backend:
  build: ./backend
  # ports:
  #   - "8000:8000"  # ← この行がコメントアウトされている
```

#### 6-2. ポート公開を有効化
docker-compose.ymlのバックエンド部分を修正：

```yaml
backend:
  build: ./backend
  ports:
    - "8000:8000"  # ← コメントアウトを解除
  environment:
    - DATABASE_URL=postgresql://user:password@database:5432/taskdb
  networks:
    - app-network
  depends_on:
    - database
```

#### 6-3. 修正を反映
```bash
# コンテナを再起動
docker compose down
docker compose up -d

# 起動状況の再確認
docker compose ps
```

**期待する結果:**
```
NAME                     COMMAND                  PORTS
infra-handson-backend    "docker-entrypoint.s…"  0.0.0.0:8000->8000/tcp
infra-handson-database   "docker-entrypoint.s…"  5432/tcp
infra-handson-frontend   "docker-entrypoint.s…"  0.0.0.0:3000->3000/tcp
```

**注目ポイント:**
- Backend: `0.0.0.0:8000->8000/tcp` （ホスト視点でアクセス可能）に変わった！

#### 6-4. 修正後の動作確認

**ホスト視点での確認:**
```bash
# バックエンドAPI確認
curl http://localhost:8000/health

# フロントエンドでの動作確認
open http://localhost:3000
```

**期待する動作:**
- ✅ APIが正常に応答する
- ✅ フロントエンドでタスク一覧が表示される
- ✅ 新しいタスクを追加できる

---

## 🔍 確認ポイント

### ✅ 視点体験チェックリスト

- [ ] ホスト視点でバックエンドにアクセスできないことを確認
- [ ] コンテナ視点では同じバックエンドにアクセスできることを確認
- [ ] フロントエンドはホスト視点でもアクセス可能なことを確認
- [ ] ポート公開設定の修正でホスト視点からもアクセス可能になることを確認
- [ ] `docker compose ps` で視点による見え方の違いを確認

### 🤔 理解度チェック

以下の質問に答えられるか確認してください：

1. **「ホスト視点」と「コンテナ視点」の違いは何ですか？**

<details>
<summary>解答を見る</summary>

- **ホスト視点**: Docker Hostの外部から見た視点。ポート公開されたサービスのみアクセス可能
- **コンテナ視点**: コンテナ内部から見た視点。同一ネットワーク内のサービスに直接アクセス可能
- **重要**: 同じアプリケーションでも、視点によってアクセス可否が変わる

</details>

2. **なぜコンテナ内からは `backend:8000` でアクセスできるのですか？**

<details>
<summary>解答を見る</summary>

- **サービス名解決**: 同一Dockerネットワーク内では、サービス名（backend）で名前解決される
- **内部通信**: ポート公開に関係なく、ネットワーク内部では直接通信可能
- **建物のアナロジー**: 部屋同士は廊下で直接繋がっているため、窓を開けなくても行き来できる

</details>

3. **実務でこの視点の違いはどう活用しますか？**

<details>
<summary>解答を見る</summary>

- **デバッグ**: 問題がどの視点で発生しているかを特定
- **セキュリティ**: 外部公開が必要なサービスと内部通信のみで十分なサービスを区別
- **設計**: マイクロサービス間の通信方式を適切に選択
- **トラブルシューティング**: アクセス問題の切り分けを効率化

</details>

---

## 🛠️ トラブルシューティング

### よくある問題と解決方法

#### 問題1: コンテナに入れない
```bash
# コンテナが起動しているか確認
docker compose ps

# コンテナ名を正確に指定
docker compose exec frontend sh
# または
docker compose exec backend sh
```

#### 問題2: コンテナ内でcurlが使えない
```bash
# 本教材ではcurlはプリインストール済みですが、
# もしエラーが出る場合は以下を実行：

# Alpine Linuxの場合、curlをインストール
apk add curl

# または、wgetを使用（標準搭載）
wget -O- http://backend:8000/health
```

#### 問題3: サービス名で名前解決できない
```bash
# 同一ネットワークに属しているか確認
docker network ls
docker network inspect <network_name>

# DNS設定を確認
nslookup backend
```

---

## 🎓 Step2で身につけたこと

- **視点の概念**: ホスト視点 vs コンテナ視点の違い
- **アクセス方法の使い分け**: 外部公開 vs 内部通信
- **デバッグ手法**: 視点を変えた問題の切り分け
- **設計思考**: どの視点からアクセス可能にするかの判断

---

## 📚 次のステップへ

Step2が完了したら、次のステップに進みましょう：

```bash
# 環境の掃除（このプロジェクトのリソースのみ削除、他の環境には影響なし）
docker compose down -v --remove-orphans

# 次のステップへ
git checkout step3-network-isolation
```

**Step3では「ネットワーク分離」を学習します。**

> 「見えない境界」の存在を体感し、同じマシン上でも通信できない理由を理解しましょう！

---

## 💡 実務への応用

Step2で学んだことは実務でこのように活用できます：

- **マイクロサービス設計**: 内部通信と外部公開の適切な使い分け
- **セキュリティ設計**: 最小権限の原則に基づくポート公開設計
- **デバッグ効率化**: 視点を変えた問題の迅速な特定
- **インフラ設計**: ネットワーク境界を意識した設計判断

---

## 📖 補足資料

**より深く学びたい方へ:**

- [ネットワークアーキテクチャ補足資料](./NETWORK_ARCHITECTURE_SUPPLEMENT.md)
  - SSR（Server-Side Rendering）パターンとの比較
  - Next.js SSRにおけるセキュリティ考慮事項
  - SSRF脆弱性、環境変数漏洩、Hydration攻撃などの最新情報