# Step1: ポートの役割再確認

## 🎯 学習目標

**このステップを通じて、あなたはこう説明できるようになります：**

> 「**待ち受け**と**接続**は別概念であり、ポート公開は外部アクセスのためのものです」

**所要時間: 約25分**

---

## 📋 今回のテーマ：「どこで待ち受けているか」を意識する

### 📚 「ポート」の語源を知る

**Port（ポート）** = **港口**

船が港に入るときを想像してください：

```
港の世界                    コンピュータの世界
┌─────────────────────────────────────────────────────────┐
│ 🏢 港口（Port）                    💻 ポート（Port）                 │
│                                                           │
│ • 船が入港する場所                  • データが入ってくる入口           │
│ • 特定の番号で管理                  • 特定の番号で管理               │
│ • 荷物の種類で使い分け            • アプリの種類で使い分け         │
│ • 外部からのアクセスを制御        • 外部からのアクセスを制御       │
└─────────────────────────────────────────────────────────┘

例：横浜港の1番埠頭           例：Webサーバーの80番ポート
   東京港の2番埠頭              メールサーバーの25番ポート
```

**重要な気づき：**
- **港口があっても、船が入港できるとは限らない**（管理上の制限）
- **ポートがあっても、外部からアクセスできるとは限らない**（設定上の制限）

このアナロジーで考えると、今回の問題が理解しやすくなります。

### 🔍 中心となる問い

> **なぜ同じアプリケーションなのに、外部からアクセスできたりできなかったりするのか？**

### 💡 実務での価値

- **ポート設定ミス**の迅速な特定
- **外部公開 vs 内部通信**の設計判断
- **セキュリティ**を考慮したポート設計

---

## 🤔 なぜこの学習が重要なのか

### 実務でよくある混乱

**場面1: 開発環境でアクセスできない**
```
「コンテナは起動しているのに、ブラウザでアクセスできません」
「ポートは8080で動いているはずなのに...」
```

**場面2: 本番環境での設定ミス**
```
「ローカルでは動くのに、サーバーにデプロイすると繋がりません」
「ファイアウォールの問題でしょうか？」
```

**場面3: セキュリティレビューでの指摘**
```
「このデータベースポート、外部公開する必要ありますか？」
「内部通信だけで十分では？」
```

### 多くのエンジニアが混同すること

❌ **「コンテナ内で動いている = 外部からアクセスできる」**
- アプリケーションが起動していても外部公開されているとは限らない

❌ **「ポート番号を変えれば繋がる」**
- ポート公開の設定がなければ何番でも繋がらない

❌ **「全部のポートを公開すれば安全」**
- 不要な公開はセキュリティリスク

✅ **正しい理解**
- **待ち受け**：アプリケーションがどのポートで動いているか
- **公開**：外部からそのポートにアクセスできるか
- **接続**：どのポートに向けて通信するか

---

## 🏗️ 今回の構成を理解する

### 現在の状態：外部アクセスできない
```
┌─────────────────────────────────────────────────────────┐
│                    app-network                          │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐  │
│  │  Frontend   │───▶│   Backend   │───▶│  Database   │  │
│  │   :3000     │    │    :8000    │    │    :5432    │  │
│  │   (React)   │    │  (Node.js)  │    │(PostgreSQL) │  │
│  │    　❌      │    │      ✅     │    │      ❌     │  │
│  │   公開なし   │    │   公開あり    │    │   公開なし   │  │
│  └─────────────┘    └─────────────┘    └─────────────┘  │
└─────────────────────────────────────────────────────────┘
        ↑                     ↑                ↑
   ❌ アクセス不可        ✅ アクセス可能    ❌ アクセス不可
   (ポート公開なし)       (ポート公開あり)   (ポート公開なし)
```

### 修正後の状態：外部アクセス可能
```
┌─────────────────────────────────────────────────────────┐
│                    app-network                          │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐  │
│  │  Frontend   │───▶│   Backend   │───▶│  Database   │  │
│  │   :3000     │    │    :8000    │    │    :5432    │  │
│  │   (React)   │    │  (Node.js)  │    │(PostgreSQL) │  │
│  │      ✅     │    │      ✅      │    │      ❌     │  │
│  │   公開あり   │    │   公開あり    │    │   公開なし   │  │
│  └─────────────┘    └─────────────┘    └─────────────┘  │
└─────────────────────────────────────────────────────────┘
        ↑                     ↑                ↑
   ✅ アクセス可能        ✅ アクセス可能    ❌ アクセス不可
   (ポート公開あり)       (ポート公開あり)   (意図的に非公開)
```

**重要な気づき：**
> データベースは**意図的に外部公開していません**。これはセキュリティのベストプラクティスです。

---

## 🚀 実習手順

> **目的**: ポート公開の有無による挙動の違いを体験し、「待ち受け」と「公開」の違いを理解する

### 1. 環境の掃除（このプロジェクトのリソースのみ削除、他の環境には影響なし）
```bash
docker compose down -v --remove-orphans
```

### 2. 現在の状態を確認（問題のある状態）
```bash
# コンテナを起動
docker compose up -d

# 起動状況の確認
docker compose ps
```

**期待する結果:**
```
NAME                     COMMAND                  PORTS
infra-handson-backend    "docker-entrypoint.s…"  0.0.0.0:8000->8000/tcp
infra-handson-database   "docker-entrypoint.s…"  5432/tcp
infra-handson-frontend   "docker-entrypoint.s…"  3000/tcp
```

**注目ポイント:**
- Frontend: `3000/tcp` （外部公開なし）
- Backend: `0.0.0.0:8000->8000/tcp` （外部公開あり）
- Database: `5432/tcp` （外部公開なし）

### 3. 問題を体験する

#### 3-1. バックエンドAPI確認（成功するはず）
```bash
curl http://localhost:8000/health
```

**期待する結果:**
```json
{"status":"OK","message":"Task API is running"}
```

#### 3-2. フロントエンド確認（失敗するはず）
```bash
# ブラウザでアクセス
open http://localhost:3000
```

**期待する結果:**
```
このサイトにアクセスできません
localhost で接続が拒否されました。
```

### 4. 問題の原因を考える

**🤔 考えてみましょう:**
1. フロントエンドのコンテナは起動していますか？
2. フロントエンドのアプリケーションは動いていますか？
3. では、なぜアクセスできないのでしょうか？

<details>
<summary>ヒントを見る</summary>

`docker compose ps` の結果を見比べてください：
- Backend: `0.0.0.0:8000->8000/tcp` 
- Frontend: `3000/tcp`

この違いは何を意味しているでしょうか？

</details>

### 5. 問題を修正する

#### 5-1. docker-compose.ymlを確認
```bash
cat docker-compose.yml
```

フロントエンドの設定を見てください：
```yaml
frontend:
  build: ./frontend
  # ports:
  #   - "3000:3000"  # ← この行がコメントアウトされている
```

#### 5-2. ポート公開を有効化
docker-compose.ymlのフロントエンド部分を修正：

```yaml
frontend:
  build: ./frontend
  ports:
    - "3000:3000"  # ← コメントアウトを解除
  environment:
    - REACT_APP_API_URL=http://localhost:8000
  networks:
    - app-network
  depends_on:
    - backend
```

#### 5-3. 修正を反映
```bash
# コンテナを再起動
docker compose down
docker compose up -d

# 起動状況の再確認
docker compose ps
```

**期待する結果:**
```
NAME                     COMMAND                  PORTS
infra-handson-backend    "docker-entrypoint.s…"  0.0.0.0:8000->8000/tcp
infra-handson-database   "docker-entrypoint.s…"  5432/tcp
infra-handson-frontend   "docker-entrypoint.s…"  0.0.0.0:3000->3000/tcp
```

**注目ポイント:**
- Frontend: `0.0.0.0:3000->3000/tcp` （外部公開あり）に変わった！

#### 5-4. 修正後の動作確認
```bash
# フロントエンドにアクセス
open http://localhost:3000
```

**期待する動作:**
- ✅ タスク管理画面が表示される
- ✅ タスク一覧が表示される
- ✅ 新しいタスクを追加できる

---

## 🔍 確認ポイント

### ✅ 体験確認チェックリスト

- [ ] ポート公開なしの状態でフロントエンドにアクセスできないことを確認
- [ ] ポート公開ありの状態でフロントエンドにアクセスできることを確認
- [ ] `docker compose ps` でポート公開状況の違いを確認
- [ ] バックエンドは最初から外部アクセス可能だったことを確認
- [ ] データベースは意図的に外部公開していないことを確認

### 🤔 理解度チェック

以下の質問に答えられるか確認してください：

1. **「待ち受け」と「公開」の違いは何ですか？**

<details>
<summary>解答を見る</summary>

- **待ち受け**: アプリケーションがコンテナ内のどのポートで動いているか（例：3000番ポート）
- **公開**: そのポートを外部（ホスト）からアクセスできるようにする設定（例：ports: "3000:3000"）
- **重要**: 待ち受けているだけでは外部からアクセスできない

</details>

2. **なぜデータベースは外部公開しないのですか？**

<details>
<summary>解答を見る</summary>

- **セキュリティ**: 外部からの不正アクセスを防ぐ
- **設計原則**: データベースは直接アクセスされるべきではない
- **内部通信で十分**: バックエンドからのアクセスのみで機能する
- **最小権限の原則**: 必要最小限のポートのみ公開

</details>

3. **`0.0.0.0:3000->3000/tcp` の意味は何ですか？**

<details>
<summary>解答を見る</summary>

- **0.0.0.0:3000**: ホスト（外部）の全インターフェースの3000番ポート
- **->**: ポートマッピング（転送）
- **3000/tcp**: コンテナ内の3000番ポート（TCP）
- **意味**: 外部の3000番ポートへのアクセスをコンテナ内の3000番ポートに転送

</details>

---

## 🛠️ トラブルシューティング

### よくある問題と解決方法

#### 問題1: 修正後もアクセスできない
```bash
# コンテナを完全に再起動
docker compose down
docker compose up -d

# ブラウザのキャッシュをクリア
# または別のブラウザで試す
```

#### 問題2: ポート番号を間違えた
```bash
# 正しいポート番号を確認
docker compose ps

# 設定ファイルを確認
cat docker-compose.yml
```

#### 問題3: コンテナが起動しない
```bash
# ログを確認
docker compose logs frontend

# イメージを再ビルド
docker compose build frontend
```

---

## 🎓 Step1で身につけたこと

- **待ち受けと公開の違い**: アプリケーションの動作 vs 外部アクセス
- **ポート設定の重要性**: 外部公開には明示的な設定が必要
- **セキュリティ意識**: 不要なポート公開は避ける
- **設計判断**: どのサービスを外部公開するかの考え方

---

## 📚 次のステップへ

Step1が完了したら、次のステップに進みましょう：

```bash
# 環境の掃除（このプロジェクトのリソースのみ削除、他の環境には影響なし）
docker compose down -v --remove-orphans

# 次のステップへ
git checkout step2-viewpoint
```

**Step2では「視点の分離」を学習します。**

> 「ホスト視点」と「コンテナ視点」の違いを理解し、「どこから見ているか」を意識できるようになりましょう！

---

## 💡 実務への応用

Step1で学んだことは実務でこのように活用できます：

- **開発環境構築**: 必要なサービスのみ外部公開する設計
- **セキュリティレビュー**: 不要なポート公開の特定と修正
- **トラブルシューティング**: アクセス問題の迅速な切り分け
- **インフラ設計**: 外部公開 vs 内部通信の適切な判断