# ネットワーク基礎ハンズオン 補足資料

## フロントエンド・バックエンド通信パターンの比較

### 1. CSR（Client-Side Rendering）パターン【現在の構成】

```
ブラウザ → バックエンドAPI（直接通信）
```

**特徴:**
- ブラウザが直接APIを叩く
- バックエンドAPIのポート公開が必要
- CORS設定が必要

**ネットワーク観点:**
- APIは外部からアクセス可能である必要がある
- ネットワーク分離の学習には適している（境界が明確）

### 2. SSR（Server-Side Rendering）パターン

```
ブラウザ → フロントエンドサーバー → バックエンドAPI
```

**特徴:**
- サーバーサイドでAPIを叩いてデータを取得
- バックエンドAPIのポート公開は不要
- より実際のプロダクション環境に近い

**ネットワーク観点:**
- APIは内部ネットワークのみでアクセス可能
- コンテナ間通信の分離をより純粋に体験できる

## Next.js SSRにおける最近のセキュリティ考慮事項

### 1. Server-Side Request Forgery (SSRF) 脆弱性

**概要:**
- SSRでサーバーサイドから外部APIを叩く際のリスク
- 攻撃者が内部ネットワークへのアクセスを試行する可能性

**対策:**
```javascript
// 危険な例
const response = await fetch(userInput); // ユーザー入力をそのまま使用

// 安全な例
const allowedHosts = ['api.example.com'];
if (!allowedHosts.includes(new URL(apiUrl).hostname)) {
  throw new Error('不正なホスト');
}
```

### 2. 環境変数の漏洩リスク

**問題:**
- Next.js 13.4以降、一部の環境変数がクライアントサイドに漏洩する可能性

**対策:**
```javascript
// サーバーサイドのみで使用する環境変数
const DATABASE_URL = process.env.DATABASE_URL; // NEXT_PUBLIC_ プレフィックスを避ける
```

### 3. Hydration攻撃

**概要:**
- SSRとCSRの状態不整合を悪用した攻撃
- 2023年に報告された新しい攻撃手法

**対策:**
- サーバーとクライアントの状態を一致させる
- 適切なCSP（Content Security Policy）の設定

## 本教材での採用理由

**CSRパターンを採用する理由:**

1. **学習効果の明確性**
   - ネットワーク境界が視覚的に理解しやすい
   - ポート公開の概念を直接体験できる

2. **トラブルシューティングの実践性**
   - 実際のSPA開発でよく遭遇するパターン
   - CORS、ポート設定などの実務的な問題を含む

3. **段階的学習**
   - まずは基本的な通信パターンを理解
   - 応用としてSSRパターンを後から学習可能

## 発展学習への道筋

1. **Step6候補: SSRパターンでの実装**
   - Next.jsを使用したSSR実装
   - コンテナ間通信のみでのAPI連携

2. **Step7候補: セキュリティ強化**
   - SSRF対策の実装
   - 適切なネットワークセグメンテーション